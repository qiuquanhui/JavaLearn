# JUC的基础概念

## 什么是JUC

JUC 是 Java.utils.concurrent 包内的类，是为了开发者可以在多线程的情况下减少竞争条件和防止死锁而出现的。



## 进程与线程

进程：程序是由指令和数据组成，当程序运行时，CPU会读取指令，执行指令，数据会加载在内存中，还有一些磁盘，网络设备之间的交换，进程就是运行中的程序：CPU 在读取指令，数据加载在内存中。

线程：进程包含一个或一个以上的线程，线程是系统最小的调度单位。多个线程共享进程的资源。

进程是系统的**资源分配**的基本单元，一个进程拥有大量的空间与资源，线程是**资源分配**的最小单位。

Java 默认的线程：Main 线程，GC 垃圾回收线程



## 并行与并发

并发：CPU只有一个核，但是有多个进程同时运行，CPU 通过快速切换时间片来切换进程的运行，所以出现类似并行的情况。在微观的角度是并发，在宏观的角度是并行。

并行：CPU 多个核，一个核对应一个进程，一起运行。真正意义上的并行。



比如：一个家庭主妇在同一时间内负责煮饭，喂奶，打扫卫生，这是并发。

​          家庭主妇雇佣了两个保姆，在同一时间内：一个负责煮饭，一个负责喂奶，家庭主妇负责打扫卫生，这是并行



## 同步与异步

从方法返回结果的角度来说：

同步：需要等待方法返回结果后才能继续往下执行代码。

异步：不需要等待方法返回结果，继续往下执行代码。



设计：比如在读取文件这样比较耗时的方法，我们可以新建线程用异步的方法执行，这样我们往下的代码就可以继续执行。提高执行效率。



## 线程的状态

新建状态：线程刚创建，还没有启动。

运行状态：线程正在运行。

堵塞状态：线程在等待某个条件，条件满足后，线程恢复运行。

等待状态：线程在运行，但是由于某些原因（比如：等待IO）暂停了。

定时等待：使用 Object.wait()等方法阻塞

死亡状态：线程已经结束。

```java
 public enum State {
        /**
           线程还没开始启动的状态
         * 新建状态.
         */
        NEW,

        /**
         * T运行状态.
         */
        RUNNABLE,

        /**
         * 堵塞状态.
         */
        BLOCKED,

        /**
         * 等待状态.
         */
        WAITING,

        /**
         * 定时等待
         */
        TIMED_WAITING,

        /**
         * 摧毁状态.
         */
        TERMINATED;
    }
```



## 原子性，有序性，可见性

可见性：CPU 加入缓存来提高与内存之间的协作事出现可见性的问题，比如当线程 A 修改了某个内存值，线程 B 不能第一时间看到，这就是可见性的问题。

有序性：程序指令优化器，为了让程序更有效率的运行，会对程序指令进行重排序，这个程序的指令顺序就会出现有序性问题。

原子性：操作系统采用分片的时间来运行线程，这就导致了线程的原子性，在 Java 程序中，一次原子性有读取与赋值都是有原子性的。



## 创建线程的方式

1. 实现 Runnable 接口，重写 run 方法。
2. 实现 Callable 接口，重写 run 方法。
3. 继承 Thread 类，重写 run 方法。



总得来说，我们还是支持实现接口来开启线程，因为继承类的话， Thread 类有许多方法与封装，会造成不必要的浪费。



## 线程之间的协作

Object 类中：wait()：等待，notiify()：唤醒，notifyAll()：唤醒全部，sleep()：休眠

condition 类中对应的：await()：等待，signal()：唤醒，sihnalAll()：唤醒全部



Object 类的方法用于在使用 sychronized 关键字的使用。

condition 的方法用于在 reentrantLock 锁的使用。



sleep()：使当前线程休眠



## JUC的架构

![img](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1714893271476-bc17a9d6-b65a-49d4-8c23-6dbc884957af.jpeg)

tools：提供同步的辅助类，如 **CountDownLatch**（闭锁），**CylicBarrier**（栅栏）和**Semaphore**（信号量），用于线程间的协调与同步。

executor：线程池的顶级接口，**ExecutorService** 是其的子接口，常用的实现类有：**ThreadPoolExecutor**（常用），SingleThreadExecutor（单个），CachedThreadPool（缓存）。

atomic：提供原子操作，比如 **AtomicBoolean**，**AtomicInterger**，一般用于多线程的环境下进行原子操作，保证操作原子性。

Locks：存放一些锁，功能更强大，比如 **ReentrantLock** 可重入锁，**ReentrantReadWriteLock**

Collections：并发集合类，比如 **copyonwirteArrayList**，**concurrentHashMap**



