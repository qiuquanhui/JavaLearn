# Redis 的过期删除机制



## 过期删除策略

1. 定时删除，当设置了 key 以及过期时间的时候，就会同时创建一个定时任务，在过期过就会触发该定时任务进行数据的删除。这个因为可能会在短时间内同时存在多个 key 键的过期，所以会造成 CPU 的性能，也会影响 Redis 的负载性能。
2. 惰性删除，当每一次访问 Redis 的 key 键值的时候，都会去查看该键值是否过期，过期的话就删除并且返回一个空数据，没有过期的时候就直接返回。因为可能会同时存在很多的过期的键值没有被删除，所以这种策略是对内存不友好的。
3. 定期删除，在一段时间内，进行定期的删除，通过检查 Redis 中是否包含有过期的键值，有的时候就进行删除，但是这个对定期的时间等等比较难以确认，如果是时间较短的话，就跟定时删除没什么区别，如果是时间较长的话，就跟惰性删除没什么区别。



三种策略的使用都不太好规划，那么到底该用哪一种呢？



## Redis 采用惰性删除与定期删除

Redis 采用惰性删除与定期删除的策略来保证过期键值的删除。

Redis 中是把所有设置了过期时间的键值都存储在过期字典中。

惰性删除：当通过Redis 查询数据的时候，会先去过期字典中判断该键值是否过期，过期的话删除键值并返回空数据，没有过期的话就直接返回。

定期删除：Redis 默认是一秒定期删除 10 次，这个可以在配置文件中设置，每一次执行删除会从过期字典中取出 20 个key，判断其中的Key 是否达到过期，是的话就删除，如果本轮检查中过期的 key 超过 5 个（4/20），也就是「过期的key」 占「总得key」的比例超过 25%，总会继续从过期字典中取出 key 进行删除。



Redis 为了防止，线程一直在执行删除，从而造成死锁，还给定期删除任务设置了时间，默认不超过 25ms，如果超过 25 ms 会自动的结束定期删除的任务。





## 内存淘汰机制

过期删除策略是应对过期键值的删除，而内存淘汰机制是应对内容过大而触发的机制。



内存淘汰机制一共为八种，主要分为两种类型，一种是「不删除数据的淘汰机制」，另一种是「删除数据的内存淘汰机制」。



## 不删除数据的淘汰机制

noeviction（Redis 3.0 以后默认的淘汰机制）：不删除数据的淘汰机制，当使用Redis 的使用，内存达到设置的最高内存，如果再进行写入的话，就会报错通知禁止写入，如果是进行非写入的操作，比如删除，查询等，就会正常的执行。



Redis 最高内存的设置，在 64 bit  的操作系统中，默认为 0 ，也就是无限大，只有超过该操作系统的内存时，Redis 才会崩溃。

在 32 bit 的操作系统中，默认为 3G，因为 32 bit 的操作系统，最大只能支持 4G，所以用 3G 来存储Redis 内存，1G 来存储其他的操作系统的数据，非常的合理



## 删除数据的淘汰机制

删除数据的淘汰机制又可以细分为「删除设置了过期时间数据」的淘汰机制和「删除所有数据」的淘汰机制。



在设置了过期时间的数据的淘汰机制

* volatile-random：随机淘汰设置了过期时间的键值
* volatile-ttl：优先淘汰更早过期的键值
* volatile-lru：redis 3.0 以前默认的淘汰机制，从设置了过期时间中，淘汰那些最近最久未使用的键值
* volatile-lfu：Redis 4.0 以后新增的淘汰机制，从设置了过期时间中，淘汰最近最少使用的键值



在所有数据中的淘汰机制

* allkeys-random：随机淘汰所有数据的键值
* allkeys-lru：在所有数据中，淘汰那些最近最久为使用的键值。
* allkeys-lfu：在所有数据中，淘汰那些最近最少使用的键值。



使用命令：config get maxmemory-policy 可以查看当前的使用策略。



如何修改淘汰策略：

* 使用命令：config set maxmemory-policy <策略>，不需要重启就生效，但是重启之后会恢复以往的配置。
* 修改配置文件，需要重启才生效。









