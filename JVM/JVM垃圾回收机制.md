# **垃圾回收**
当我们写C语言时，创建对象之后，需要手动的删除对象。
而我们写 Java 语言的时候却不用手动的删除对象，这就依赖于我们 JVM 的垃圾回收算法。

**什么是垃圾**：只要不需要的引用对象，就是垃圾。
**垃圾回收作用在哪：**垃圾回收主要作用在堆中

我们回到这张图。
![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715246803907-7652d8d9-7bdd-40f1-b27d-f2e0fd96877e.jpeg)
看到堆的比例，新生区占 三分之一，新生区中又分为 eden区占十分之八 和 survivor from 区 十分之一 与survivor to 区 十分之一。
JVM 新建对象的时候，对象的信息是存储在 eden 区
因为我们 GC 的使用是不可访问应用程序的，为了缩短 GC 的时间，JVM 会把经常使用到的引用对象从 Eden 区进入到survivor区，再从 survivor 区进入到 养老区。
这样就可以减少GC的引用对象了。
那么到底是如何进行垃圾回收——垃圾回收算法。
下面介绍这三种方法

1. 标记清除法
2. 标记复制法
3. 标记整理法
## 垃圾回收算法
### 引用计数法
引用计数法是对象被引用了，计数器+1，引用结束，计数器-1，当计数器为 0 就会被回收
缺点:计数器本身存在内存消耗，加大了程序的内存消耗。
### 标记清除算法
标记清除分两次扫描

- 第一次扫描，扫描区域，对需要回收的对象进行标记

比如下方的将需要回收的对象标记为灰色(举例)
![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715259169573-47f711fc-47d4-478a-90a6-08a746d282fb.jpeg)

- 第二次扫描，把没有标记的对象进行清除

![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715259833736-05a032b7-6692-40d8-9ec8-b92046c75ca5.jpeg)
这种方法比较简单，存在以下的缺点

- **第一：存在内存碎片，因为回收的空间是分散在各个内存空间中，会产生内存碎片。**
- **两次扫描，存在时间成本**

因此出现标记复制法和标记整理法来解决内存碎片的问题。

### 标记复制算法
为什么新生代的幸存区分为 from 区和 to 区吗，就是用来使用标记复制算法的。
垃圾回收，回收前：将新生代需要存活的对象以及 from 区需要存活对象一起复制到 to 区中。
from 区与 to 区的位置互换。
![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715259833853-5afac820-c455-46d7-b034-e9df2645303a.jpeg)
回收后，将其中一块完全清除。
![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715260268272-416c78fd-9d5c-41b3-83ba-5213812e8cb7.jpeg)
好处:没有内存碎片
坏处:浪费了内存空间 因为总有一遍是空的，如果对象100%存活的极端情况下，复制的对象是极大的，所以该算法只适用于新生区的GC使用
### 标记整理算法
第一次扫描，进行标记之后先整理再清除
**整理：把存活的对象放在同一块内存块中**
![](https://cdn.nlark.com/yuque/0/2024/jpeg/33747484/1715259169573-47f711fc-47d4-478a-90a6-08a746d282fb.jpeg)



![image-20240529190502361](https://images-1314004726.cos.ap-guangzhou.myqcloud.com/test/202405291905408.png)



- **进行多次扫描，清除，一般为5次**
- **开始压缩**



## 总结
垃圾回收算法(Garbar Collector) 又称为分代算法，没有最好的算法，只有合适的算法，在合适的空间使用合适的算法。

时间效率：复制算法 > 标记清除算法 > 标记整理压缩算法 （时间复杂度）
内存整齐度：复制算法 > 标记整理 > 标记清除
内存利用率： 标记整理 > 标记清除 > 复制

年轻代：存活率低，使用复制算法

老年代：区域大,存活率高，使用标记清除，标记整理
